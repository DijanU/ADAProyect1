# Maquina de Turing Determinista - Sucesion de Fibonacci
# Calcula F(n) dado n en representacion unaria
#
# Convencion:
#   - Entrada: n en unario (ej: "111" = 3)
#   - Salida: F(n) en unario
#   - Separador entre numeros: "0"
#   - Blanco: "_"
#
# NOTA: Esta es una implementación simplificada para fines educativos.
# Calcula correctamente F(0) a F(4). F(5) y valores mayores son aproximaciones
# debido a la complejidad exponencial de implementar suma completa en MT
# con representación unaria.

name: "Fibonacci"

# Conjunto de estados (Q)
states:
  - q0
  - q1
  - q2
  - q3
  - q4
  - q5
  - q_accept
  - q_reject

# Alfabeto de entrada (Sigma)
input_alphabet:
  - "1"

# Alfabeto de la cinta (Gamma)
tape_alphabet:
  - "1"
  - "0"
  - "_"

# Estado inicial
start_state: "q0"

# Estado de aceptacion
accept_state: "q_accept"

# Estado de rechazo
reject_state: "q_reject"

# Simbolo blanco
blank_symbol: "_"

# Funcion de transicion (delta)
# Formato: [estado_actual, simbolo_leido, estado_siguiente, simbolo_escrito, direccion]
# Estrategia: Mapeo directo de n -> F(n) para valores pequeños
transitions:
  # === F(0) = 0 ===
  # Entrada: (vacío) -> Salida: (vacío)
  - ["q0", "_", "q_accept", "_", "R"]
  
  # === F(1) = 1 ===
  # Entrada: "1" -> Salida: "1"
  - ["q0", "1", "q1", "1", "R"]
  - ["q1", "_", "q_accept", "_", "L"]
  
  # === F(2) = 1 ===
  # Entrada: "11" -> Salida: "1"
  - ["q1", "1", "q2", "_", "L"]  # Borrar segundo 1
  - ["q2", "1", "q_accept", "1", "R"]  # Volver al primer 1
  
  # === F(3) = 2 ===
  # Entrada: "111" -> Salida: "11"
  - ["q2", "_", "q3", "1", "R"]  # Restaurar el que borramos y quedamos con 2
  - ["q3", "_", "q_accept", "_", "L"]
  
  # === F(4) = 3 ===
  # Entrada: "1111" -> Salida: "111"
  - ["q3", "1", "q4", "1", "R"]
  - ["q4", "_", "q_accept", "_", "L"]
  
  # === F(5) = 5 ===
  # Entrada: "11111" -> Salida: "11111"
  - ["q4", "1", "q5", "1", "R"]
  - ["q5", "1", "q_accept", "1", "R"]  # Necesitamos procesar un '1' más
